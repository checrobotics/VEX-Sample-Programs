#pragma config(Motor,  port2,           rightMotor,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                 - VEXnet Accelerometer Control -                                   *|
|*                                     ROBOTC on VEX 2.0 Cortex                                       *|
|*                                                                                                    *|
|*  This program uses the built-in Accelerometer Sensor of the VEX 2.0 CORTEX Controller to control   *|
|*  the robot.                                                                                        *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Tilting the controller DOWN, or FORWARD, gives a NEGATIVE reading on Y.                     *|
|*    2)  Tilting the controller UP, or BACK, gives a POSITIVE reading on Y.                          *|
|*    3)  Tilting the controller LEFT gives a NEGATIVE reading on X.                                  *|
|*    4)  Holding the controller RIGHT gives a POSITIVE reading on X.                                 *|
|*    5)  'abs(z)' is the ABSOLUTE VALUE of 'z'.                                                      *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]              [Name]              [Type]              [Description]                   *|
|*    Motor - Port 2          rightMotor           VEX Motor           Right motor                    *|
|*    Motor - Port 3          leftMotor            VEX Motor           Left motor                     *|
\*----------------------------------------------------------------------------------------------------*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
  int accel_x   = 0;      // Will hold the controller-accelerometer X reading.
  int accel_y   = 0;      // Will hold the controller-accelerometer Y reading.

  int prev_x    = 0;      // Will hold the previous accelerometer X reading (for comparison).
  int prev_y    = 0;      // Will hold the previous accelerometer Y reading (for comparison).

  int threshold = 10;     /* Used to cancel 'noise' of low values as well as */
                          /* ignore spikes in accelerometer sensor readings. */

  while(1 == 1)
  {
    prev_x = accel_x;           // update previous x reading to 'accel_x'
    prev_y = accel_y;           // update previous y reading to 'accel_y'
    accel_x = vexRT[AccelX];    // update 'accel_x' to new current reading
    accel_y = vexRT[AccelY];    // update 'accel_y' to new current reading

    // is abs(current - prev) < threshold?
    if( (abs(accel_x - prev_x) < threshold) || (abs(accel_y - prev_y) > threshold) )
    {
    // YES.
      // Are either of them over the 'noise' threshold?
      if( (abs(accel_x) > threshold) || (abs(accel_y) > threshold) )
      {
      // YES.
        if(accel_y > 0) // going backwards?
        {
          motor[leftMotor]  = ((-1 * accel_y) - accel_x)/2;
          motor[rightMotor] = ((-1 * accel_y) + accel_x)/2;
        }
        else  // going forward, or point turn:
        {
          motor[leftMotor]  = ((-1 * accel_y) + accel_x)/2;
          motor[rightMotor] = ((-1 * accel_y) - accel_x)/2;
        }
      }
      // NO - give no power to motors, joystick is in center position (or near enough to it)
      else
      {
        motor[leftMotor]  = 0;
        motor[rightMotor] = 0;
      }
    // NO - make no changes.
    }
    wait1Msec(20);      // the VEXnet controller updates every 15ms or so
  }
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
