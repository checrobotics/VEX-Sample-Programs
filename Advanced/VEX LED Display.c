#pragma config(Sensor, dgtl1,  LED1,                sensorDigitalOut)
#pragma config(Sensor, dgtl2,  LED2,                sensorDigitalOut)
#pragma config(Sensor, dgtl3,  LED3,                sensorDigitalOut)
#pragma config(Sensor, dgtl4,  LED4,                sensorDigitalOut)
#pragma config(Sensor, dgtl5,  LED5,                sensorDigitalOut)
#pragma config(Sensor, dgtl6,  LED6,                sensorDigitalOut)
#pragma config(Sensor, dgtl7,  LED7,                sensorDigitalOut)
#pragma config(Sensor, dgtl8,  LED8,                sensorDigitalOut)
#pragma config(Motor,  port1,           Audio,         tmotorAudio, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////
//
//                               VEX LDC Demo Program
//
// Short program to illustrate control over eight LEDs connected to VEX digital
// output ports. The display techniques can be applied to any micro-controller with
// digital outpus and not just the VEX.
//
// The program is written for the ROBOTC system and utilizes its multi-tasking
// capabilities. Multi-tasking allows the program to run two "tasks" at the same time
// and the ROBOTC system will share the VEX CPU time between the two tasks. This is
// similar to working on the PC and editing a document while the email system is
// simultaneously downloading new messages.
//
// It's a little bit more complicated to use multi-tasking. But it's really useful
// in this application because it makes it really easy to add some clever LED displays
// to any program.
//    1. Simply add a call to "StartTask(LED_Display)" to your existing program. This
//       starts the task that draws the LED values.
//    2. Copy the contents of the "LED_Display" task into your program and modify it
//       as appropriate to display whatever pattern you want.
//
///////////////////////////////////////////////////////////////////////////////////////

tSensors nLED;

///////////////////////////////////////////////////////////////////////////////////////
//
//                             LED Display Utility Routines
//
// A couple of useful utility routines to turn all of the LEDs OFF or ON.
//
///////////////////////////////////////////////////////////////////////////////////////

void allOff()
{
  for (nLED = LED1; nLED <= LED8; ++nLED)
    SensorValue[nLED] = 0;
  return;
}

void allOn()
{
  for (nLED = LED1; nLED <= LED8; ++nLED)
    SensorValue[nLED] = 1;
  return;
}


///////////////////////////////////////////////////////////////////////////////////////
//
//                          Sample LED "Pattern" Displays
//
// Many sample functions to draw a different pattern on the LEDs.
//
///////////////////////////////////////////////////////////////////////////////////////

void drawLeft()
{
  //
  // Seqeuentially turns on all the LEDs in a row with a brief delay between each
  //
  allOff();
  for (nLED = LED1; nLED <= LED8; ++nLED)
  {
    wait1Msec(100);
    SensorValue[nLED] = 1;
  }
  wait1Msec(400);
}


void drawRight()
{
  //
  // Seqeuentially turns on all the LEDs in a row with a brief delay between each
  //
  allOff();
  for (nLED = LED8; nLED >= LED1; --nLED)
  {
    wait1Msec(100);
    SensorValue[nLED] = 1;
  }
  wait1Msec(400);
}

void Flash()
{
  //
  // Briefly flashes all the LEDs
  //
  allOn();
  wait1Msec(150);
  allOff();
  wait1Msec(150);
}

void drawCrossed()
{
  //
  // Seqeuentially turns on all the LEDs in a row with a brief delay between each
  //
  for (int i = 0; i <= 7; ++i)
  {
    allOff();
    SensorValue[LED1 + i] = 1;
    SensorValue[LED1 + (7 - i)] = 1;
    if (i == 3)
      i += 2;
    wait1Msec(75);
  }

  for (int i = 1; i <= 7; ++i)
  {
    allOff();
    SensorValue[LED1 + i] = 1;
    SensorValue[LED1 + (7 - i)] = 1;
    if (i == 3)
      i += 2;
    wait1Msec(75);
  }
}


///////////////////////////////////////////////////////////////////////////////////////
//
//                        Cylon Eye Scanner
//
// Several functions used to draw a "Cylon" eye scanner using the LEDs. [i.e. from the
// robot in the Battlestar Galactia TV series.
//
// A pair of LEDs marches back and forth across the 8 LEDs.
//
///////////////////////////////////////////////////////////////////////////////////////

void cylonEye()
{
  for (nLED = LED1; nLED <= LED8; ++nLED)
  {
    if (nLED > LED2)
      SensorValue[nLED - 2] = 0;
    SensorValue[nLED] = 1;
    wait1Msec(75);
  }

  for (nLED = LED8; nLED >= LED1; --nLED)
  {
    SensorValue[nLED] = 1;
    if (nLED == LED8)
      SensorValue[LED7] = 0;
    else
      SensorValue[nLED + 1] = 0;
    wait1Msec(75);
  }
}

////////////////////////////////////////////////////////////////////////////////////
//
//                                  task LED_Display
//
// This task looks after drawing all the LEDs. It simply loops forever drawing each
// of the various patterns six times before moving to the next pattern.
//
// Modify this as appropriate to display whatever patterns you wish on the VEX LCD.
//
////////////////////////////////////////////////////////////////////////////////////


task main()
{
  int nState = 4;

  while (true)
  {
    for (int i = 0; i < 6; ++i)
    {
      switch (nState)
      {
      default:
        nState = 0;
        // Fall through to next case

      case 0:   cylonEye();           break;
      case 1:   drawRight();          break;
      case 2:   drawLeft();           break;
      case 3:   Flash();              break;
      case 4:   drawCrossed();        break;
      }
    }
    ++nState;
    wait1Msec(500);
  }
}
